<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Lightning AI : A JNIBWAPI bot for playing StarCraft: Brood War">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Lightning AI</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/Shadowen/Lightning-AI">View on GitHub</a>

          <h1 id="project_title">Lightning AI</h1>
          <h2 id="project_tagline">A JNIBWAPI bot for playing StarCraft: Brood War</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/Shadowen/Lightning-AI/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/Shadowen/Lightning-AI/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <p>Strategy game AI has been in development for a long time. Perhaps most famously, the AI Deep Blue was known for defeating chess champion Garry Kasparov in 1997. Deep Blue used opening and closing tables extensively, but achieved its strength mainly through brute force searching of the game space. However, modern video games - including the real-time strategy genre - involve continuous positions and simulatenous gameplay, making any sort of tree traversal search infeasible. This calls for a vastly different AI structure to play the modern strategy game.</p>

<p>Lightning AI is a finite state automata designed to play Blizzard's iconic real-time strategy game StarCraft: Brood War. It makes use of the third-party libraries BWAPI and BWMirror to interface with the game as a player.</p>

<h1>
<a id="design-principles" class="anchor" href="#design-principles" aria-hidden="true"><span class="octicon octicon-link"></span></a>Design Principles</h1>

<h2>
<a id="non-cheating" class="anchor" href="#non-cheating" aria-hidden="true"><span class="octicon octicon-link"></span></a>Non-Cheating</h2>

<p>Most modern game developers rely on giving the AI access to information and resources that are normally unavailable to a player in order to present a suitably difficult challenge. For example, the AI opponent may be able to see into the fog of war, ignore resource requirements, or produce bonus units.
BWAPI restricts the information that the AI can obtain to the same information that would be available to a player in the game. The AI may not see units and buildings that have passed into the fog of war. Furthermore, BWAPI also restricts the commands that may be issued by the AI. The AI may only build units and otherwise issue commands that a player would be allowed to.</p>

<h2>
<a id="competitive" class="anchor" href="#competitive" aria-hidden="true"><span class="octicon octicon-link"></span></a>Competitive</h2>

<p>The primary purpose of Lightning is to compete against other AIs of the same type. Tournaments hosted by various organizations such as  pit AI against AI. The goal of  is to achieve a high ranking on the tournament ladder.</p>

<h2>
<a id="adaptive" class="anchor" href="#adaptive" aria-hidden="true"><span class="octicon octicon-link"></span></a>Adaptive</h2>

<p>AIs also tend to play against human opponents. Here,  should be able to hold its own against poor to intermediate opponents. A large complication in playing against human opponents is their unpredictability.  should be able to adapt to changing situations, including some anti-computer tactics employed by human opponents.</p>

<h2>
<a id="modular" class="anchor" href="#modular" aria-hidden="true"><span class="octicon octicon-link"></span></a>Modular</h2>

<p>The source code of the AI should be built to accomodate a number of strategies. Adjustments to the core strategy and details alike should be easy to make.</p>

<h1>
<a id="features" class="anchor" href="#features" aria-hidden="true"><span class="octicon octicon-link"></span></a>Features</h1>

<h2>Debug Manager</h2>
<p>A powerful, yet simple to implement debug manager allows the programmer to quickly and easily see what the AI is thinking at any given time. The debugger is modular so different sets of information can be quickly displayed or hidden at a keystroke.</p>

<p>
  Writing a module for the debugger is as simple as knowing what you want to display and how. The main module resides in a static class called <code>DebugManager</code>. To display information through it, you must first register a <code>DebugModule</code>, as below. This is a fire-and-forget method: each debug module only has to be registered once.
</p>
<!-- HTML generated using hilite.me --><div style="background: #ffffff; overflow:auto;width:auto;border:solid gray;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><table><tr><td><pre style="margin: 0; line-height: 125%">1
2
3
4
5
6</pre></td><td><pre style="margin: 0; line-height: 125%">createDebugModule<span style="color: #333333">(</span><span style="background-color: #fff0f0">&quot;example&quot;</span><span style="color: #333333">)</span>
	<span style="color: #333333">.</span><span style="color: #0000CC">addCommand</span><span style="color: #333333">(</span>
<span style="color: #008800; font-weight: bold">null</span><span style="color: #333333">,</span> <span style="color: #333333">(</span>c<span style="color: #333333">)</span> <span style="color: #333333">-</span> <span style="color: #333333">&gt;</span> <span style="color: #333333">{</span>
	GameHandler<span style="color: #333333">.</span><span style="color: #0000CC">sendText</span><span style="color: #333333">(</span><span style="background-color: #fff0f0">&quot;The example draws stuff.&quot;</span><span style="color: #333333">))</span>
	<span style="color: #333333">.</span><span style="color: #0000CC">addAlias</span><span style="color: #333333">(</span><span style="background-color: #fff0f0">&quot;help&quot;</span><span style="color: #333333">)</span>
	<span style="color: #333333">.</span><span style="color: #0000CC">setDraw</span><span style="color: #333333">(()</span> <span style="color: #333333">-</span> <span style="color: #333333">&gt;</span> DrawEngine<span style="color: #333333">.</span><span style="color: #0000CC">drawCircleScreen</span><span style="color: #333333">(</span><span style="color: #0000DD; font-weight: bold">320</span><span style="color: #333333">,</span> <span style="color: #0000DD; font-weight: bold">120</span><span style="color: #333333">,</span> <span style="color: #0000DD; font-weight: bold">10</span><span style="color: #333333">,</span> Color<span style="color: #333333">.</span><span style="color: #0000CC">Red</span><span style="color: #333333">,</span> <span style="color: #008800; font-weight: bold">false</span><span style="color: #333333">);</span>
</pre></td></tr></table></div>
<p>
  The internal interface relies heavily on function-chaining to make the declarations fluent. Used in conjunction with Java 8 lambda functions and functional interfaces, the entire interface is very fluent and easy to read. The interface was designed this way so that the lambda function passed to <code>setDraw(...)</code> would be in the same lexical scope as the declaring class and therefore have access to private and protected variables for quick and easy debugging.
</p>
<p>
  And you're good to go! The debugger should not interfere with regular operation of the class. It simply serves as an easy way to display the internal state of various parts of the AI. 
</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Lightning maintained by <a href="https://github.com/Shadowen">Shadowen</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>
  </body>
</html>
